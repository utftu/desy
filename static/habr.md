# JS. Валидатор. Пишем свой YUP.

## Для чего нужна валидация при разработке и когда ее применять?

В web разработке при работе с пользовательскими данными валидация должна применяться при получении данных сервисом. Условно можно разделить валидацию на:

- **Клиентскую.** При вводе данных в формы важно провалидировать введенные данные и сообщить пользователю о их некорректности. Это дает понятный обратный отклик пользователю о его действиях и предотвращает дальнейшие некорректные действия в сервисе.ы
- **Серверную.** Любой код, выполняемый на клиенте, также как и запрос, поступающий от клиентского приложения, не может считаться доверенным и должен быть провалидирован. Мы не можем рассчитывать на то, что клиентское приложение гарантировано подготовит корректные данные данные, так как при разработке может возникнуть неконсистентнсоть логики работы с данными на сервере или на клиенте. При этом мы также можем столькнуться со случаем когда клиент вручную подготавливает данные маскируясь под приложениее

В целом, данные следует валидировать как можно чаще, особенно в контексте полного цикла разработки на сервере и на клиенте. Давайте рассмотрим, какие библиотеки существуют для этой цели в настоящее время.

## Анализ существующих решений

Из популярных решений которые могут применяться как на клиенте так и на сервере можно выделить `yup` и `zod`. Пройдемся по их особенностям и отметим для себя их недостатки

В целом обе библитеки страдают от:

- **Излишнее многообразие функциональности.** К этому можно отнести как и приведение типов - обе библиотеки предоставляют функциональность преобразования типов при валидации, так и стремление предусмотреть все возможные случае, что увеличивает размер кодовой базы и уменьшает понятность кода для других разработчиков, которые решаться залезть в имходники. Для примера метод [getIn](https://github.com/jquense/yup/blob/5c77e0d4f9373151bcf0cd558c95986b6e4800d7/src/util/reach.ts#L6) в yup и [непролходимое поле regexp](https://github.com/colinhacks/zod/blob/18a0c288a361c0f7c269829f576494280ec9b1a8/src/types.ts#L583), [методы которые обязаны предусматривать все варианты конфига](https://github.com/colinhacks/zod/blob/18a0c288a361c0f7c269829f576494280ec9b1a8/src/types.ts#L4271) в zod (Не говоря уже про файлы размером в 6000 строк).
- **Игнорирование вопросов производительности.** Обе библиотеки делают упор скорее на расширение функциональности, чем на прозизводтельность того что у них есть. Это проявляется в любых мелочах, например в этих библиотеках добавление любого нового правила валидации приводит к полному копированию сущности [yup](https://github.com/jquense/yup/blob/5c77e0d4f9373151bcf0cd558c95986b6e4800d7/src/schema.ts#L773), [zod](https://github.com/colinhacks/zod/blob/18a0c288a361c0f7c269829f576494280ec9b1a8/src/types.ts#L868C3-L868C12). Особенные проблемы с производительностью у yup, о чем я упомяну далее

## Архитектура библиотеки

### Принципы

Попробдуем создать свою библеотку, избежав указанных выше проблем. Для этого сформилируем принципы которыми мы должно руководстоваться

- Код должен быть **простым**
- Код должен быть **производительным** на столько, на сколько это позволяет предидущий пункт

### Структура

Будем отталкиваться от конечно кода который мы бы хотели видеть. По аналогии в указанными выше библиотеками выглядеть это должно примерно вот так

```ts
const schema = string().min(2);
const value = 'hello';

schema(value);
```

Нужно отметить что тут присутсвует 2+ валидации

- string() - проверяет что value является строком (по умолчанию пустой)
- min(2) - проверяет что длина строки должна быть как минимум 2 символа

Эти условия мы могли бы чейнить и дальше, но мы уже видим главное, структруа которую мы выберем для хранения правил валидации должна поддерживать неограниченный список правил. Выглядеть это может примерно вот так

Мы может

```ts
type Checker = () => string;
class String {
  conditions: Checker[] = [];

  constructor() {
    // Добавление правила валидации
    this.conditions.push((value) => {
      if (typeof value !== 'string') {
        return 'Is not a string';
      }
      return '';
    });
  }

  min(num: string) {
    // Добавление правила валидации
    this.conditions.push((value) => {
      if (value.length < min) {
        return 'Too short string';
      }
      return '';
    });

    // Возвращение всей сущности для возможности чейнинга
    return this;
  }
}
```

Теперь для того чтобы узнать провалидиировать передамаемые данные осталось узнать существует ли такой codition который вернет не пустую строку при выполнении

```ts
type Checker = () => string;
class String {
  conditions: Checker[] = [];
  // ...
  validate(value: any) {
    for (const condition of this.confiditons) {
      const error = condition(value);
      if (error !== '') {
        return error;
      }
    }

    return '';
  }
}
```

Здесь можно заметить что мы останавливаемся на первой встреченной ошибке и прекращаем цикл проверок. В реальном мире это добавит производительности нашему решению. Такому же подходу мы будет следовать при работе с другими данными вроед объектов - прерывать перебор при выявлении первое ошибки. Такое решение может кому-то показаться но на мой взгляд оно является самым практичным:

- Если нам интересна каждая ошибка в данных, напрмиер при валидации форм, то каждой сущности(поле ввода) необходимо написать свою валидацию
- Если нам интресно почему сервер не принял наши данные, и мы предполагаем что есть несколько причин. Сначала можно исправить уже указанные, а потом исправлять новые

Мы предусмотрели несколько проверок. Но жизнь всегда многообразнее, и стоит позволить разработчику самому добавлять правила помимо стандартных

```ts
type Checker = () => string;
class String {
  conditions: Checker[] = [];

  test(checker: (value: any) => string) {
    this.conditions.push(checker);
    return this;
  }
}
```

Сразу отметим что `validate()`, `test()`, `conditions()` кажутеся общими методами/свойствами, без который не обойдется ни один тип валидации. Поэтому вынесем их в отдельный класс от которого будет наследовать все наши конкретные типы. Финальный коде будет выглядеть так:

```ts
type Checker = (value: any) => string;
class Schema {
  conditions: Checker[] = [];

  validate(value: any) {
    for (const condition of this.conditions) {
      const error = condition(value);
      if (error !== '') {
        return error;
      }
    }

    return '';
  }

  test(checker: Checker) {
    this.conditions.push(checker);
    return this;
  }
}

class String extends Schema {
  constructor() {
    super();
    this.conditions.push((value) => {
      if (typeof value !== 'string') {
        return 'Is not a string';
      }
      return '';
    });
  }

  min(min: number) {
    this.conditions.push((value) => {
      if (value.length < min) {
        return 'Too short string';
      }
      return '';
    });

    return this;
  }
}

const checkUpperCase = (value: string) => {
  if (value !== value.toUpperCase()) {
    return 'NOT UPPER CASE';
  }

  return '';
};
const string = () => new String();
const schema = string().min(2).test(checkUpperCase);

const valueValid = 'HELLO';
const valueError = 'Hello';

console.log(schema.validate(valueValid)); // ''
console.log(schema.validate(valueError)); // 'NOT UPPER CASE'
```

Отмечу что [реальный пример](https://github.com/utftu/desy/blob/446eb4f40082b3a97875784faaec4f533511850d/src/string/string.ts#L57) только немного сложнее, поскольку

- conditions - должен содержать имена правил, чтобы в определенных случаях их можно было заменить или убрать. Поэтому вместо обычных функций стоит использовать объекты который содержат имена и эти функции
- сообщение об ошибке от checker хотелось бы видеть более информативным, при сложной вложенной структуре в тексте пригодился бы пусть - где именно произошла ошибка

### Вложенные структуры

Мы написали отличный код для примитива, а что делать с более сложными структурами? Например

```ts
const user = {
  name: 'Aleksey',
  age: 42,
};
```

Для этого нам понадобится отдельная сущность object(), которая позволит писать вложенные правила

```ts
const schema = object({
  name: string(),
  age: number(),
});
```

```ts
class Object extends Schema {
  constructor(objSchema) {
    super();
    this.conditions.push((obj) => {
      for (const key in objSchema) {
        const innerSchema = objSchema[key];

        // innerSchema сама знает как провалидировать данные, нас остается только ее запустить
        const error = innerSchema.validate(obj);
        if (error !== '') {
          return `${key} props has wrong type`;
        }
      }

      return '';
    });
  }
}
```

### Ts типы

Описывая схему, мы по сути уже указываем типы, которые должны быть в валидируемом объекте. Используя ts мы вполне можем избавить разработчика от необходимости описывать типы несколько раз. Для того чтобы это реализовать попробуем сделать немного багии ts

Простой пример

```ts
const schema = string();
const rawValue = 'hello';

const error = schema(rawValue);
if (error !== '') {
  // do something
}

const value = rawValue as Infer<typeof schema>; // string type
```

Попробуем это реализовать. Как основу идею создадим внутренее поля types, который будет хранить тип сущности и откуда Infer сможет получить необходимый наш тип

```ts
class Schema<TValue> {
  types!: TValue;
}

class String extends Schema<string> {}

type Infer<TType extends Schema<any>> = TType['types'];
```

Работает! Теперь перейдем к более сложному примеру

```ts
const rawUser = {
  name: 'Aleksey',
};

const schema = object({
  name: string(),
});

const error = schema(rawUser);
if (error !== '') {
  // do something
}

const user = rawUser as Infer<typeof schema>; // {name: string, age: number} type
```

Попробуем реализовать. Сейчас будет немного магии ts, поэтому уберите детей и последователей Flow

```ts
type Infer<TType extends Schema<any>> = TType['types'];

class Schema<TValue> {
  types!: TValue;
}

class String extends Schema<string> {}

const string = () => new String();

type ObjectValue = Record<string, Schema<any>>;
type PreparedTypes<TValue extends ObjectValue> = {
  [K in keyof TValue]: Infer<TValue[K]>;
};

class ObjectVidator<
  TValue extends ObjectValue,
  TValueTypes = PreparedTypes<TValue>,
> extends Schema<TValueTypes> {
  value: TValue;

  constructor(value: TValue) {
    super();
    this.value = value;
  }
}

function object<TValue extends ObjectValue>(value: TValue) {
  return new ObjectVidator(value);
}

const schema = object({
  name: string(),
});

type User = Infer<typeof schema>; // {name: string} type
```

### Реальная библиотека

Подходы описанные выше верхнеуровнево описывают концепциию библиотеки которую можно реализовать. Теперь дело за доавблением конкретных типов для number, boolean и так далее. При этом создание реальной библиотеки потребует большее количество ресурсов. Путь описанный выше я проделал при написании своей билиотеки desy. В ней вы можете подсмотреть как выглядеть указанный код на самом деле и если захотите использовать в своем проекте

[desy](https://github.com/utftu/desy) - Dead Extraordinary Simple Yup

#### Мысли о производительности

После написание библиотеки меня удивило на сколько desy оказался более производтельныи чем другие решение. Я ожидал ожидал лучших бенчрмарков, но не такого бурного прироста какой произошел на самом деле. Как причину можно выделить

- отказа от прокидывания ошибок
- отказа от валидации при нахождении ошибок
- отказа от иммутабельных структур и усложненного кода с глубоким ветвление

Писать конкретные цифры всегда сомнительное дело, поэтому замеры можно изучить самостоятельно [самостоятельно](https://github.com/utftu/desy/blob/master/bench.ts)

### Вопросы которые могли остаться

- Почему индиактор ошибки строка?
  Строка является самым выразительным средством сообщение о деталях ошибких, учитывая что мы отказались от прокидывания ошибок
- Почему не пробрасываем ошибки?
  Проброс ошибок является операцией которая должна сообщать о непридвиденной работе прилоежния. Несоотвествие данных схеме, при том что это происходит внутри специально созданной для этого прогаммы нельзя назвать непредвиденной работой. Мы букально просим сообщить программу о том являются ли данные валидными или нет. Для этого должны использоваться обычные способы работы с данными. Плюс производительность
- Почему все проверки синхронные?
  Поддержка аснихронный проверок потребовало бы увеличения кодовой базы и разветвления логики выполнени. В моей практики асинхронные проверки почти всегда не имеют смысла

## Заключение

Как итог хотелось бы сказать:

- Многие библитеки которые мы используем в повседневной жизни жизни не являются ни производительными, ни понятными и не побоюсь сказать - хорошыми. Мы просто привыкли к этим инструментам и часто всопринимаем как что-то глобальное и незыблемое. Иногда нужно писать свои велосипеды и возможно какой-то и из них окажется лучше оригинала. Не стоит забывать что многие популярные библиотеки это ответ автора - на то что ему что-то ее понравилось в уже существующих на тот момент
- Валидируйте данные. Серьезно. Пользователю нельзя доверять. И лучше используйте для валидации [desy](https://github.com/utftu/desy)
